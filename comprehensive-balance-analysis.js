const { PrismaClient } = require('@prisma/client')
const prisma = new PrismaClient()

async function comprehensiveBalanceAnalysis() {
  console.log('üéØ AN√ÅLISE ABRANGENTE: Balanceamento de Valores vs Sistema Completo\n')
  
  // 1. Buscar dados do sistema
  console.log('üìä COLETANDO DADOS DO SISTEMA...\n')
  
  // Pacotes de cr√©ditos
  const creditPackages = await prisma.creditPackage.findMany({
    where: { isActive: true },
    orderBy: { displayOrder: 'asc' }
  })
  
  // Pacotes (tipos de packs)
  const packs = await prisma.pack.findMany({
    where: { isActive: true },
    include: {
      probabilities: true,
      customType: true
    }
  })
  
  // Itens Genesis
  const genesis = await prisma.collection.findFirst({
    where: { name: 'Genesis - Primeira Era' }
  })
  
  const items = await prisma.item.findMany({
    where: { collectionId: genesis.id },
    select: {
      name: true,
      rarity: true,
      scarcityLevel: true,
      value: true,
      isUnique: true,
      isLimitedEdition: true
    },
    orderBy: [{ rarity: 'asc' }, { value: 'asc' }]
  })
  
  console.log('üí∞ PACOTES DE CR√âDITOS DISPON√çVEIS:')
  creditPackages.forEach(pkg => {
    const efficiency = (pkg.credits / pkg.price).toFixed(1)
    const popular = pkg.isPopular ? ' ‚≠ê' : ''
    console.log(`   R$ ${pkg.price.toFixed(2)} ‚Üí ${pkg.credits} cr√©ditos (${efficiency} cr√©ditos/real)${popular}`)
  })
  console.log('')
  
  console.log('üì¶ TIPOS DE PACOTES E PROBABILIDADES:')
  packs.forEach(pack => {
    console.log(`   ${pack.customType?.emoji || 'üì¶'} ${pack.name}: ${pack.price} cr√©ditos`)
    pack.probabilities.forEach(prob => {
      console.log(`      ${getRarityEmoji(prob.rarity)} ${prob.rarity}: ${prob.percentage}%`)
    })
    console.log('')
  })
  
  // 2. An√°lise de probabilidades vs valores
  console.log('üé≤ AN√ÅLISE: Probabilidade vs Valor dos Itens\n')
  
  // Calcular valores m√©dios por raridade
  const rarityStats = {}
  items.forEach(item => {
    if (!rarityStats[item.rarity]) {
      rarityStats[item.rarity] = {
        count: 0,
        values: [],
        scarcities: {}
      }
    }
    rarityStats[item.rarity].count++
    rarityStats[item.rarity].values.push(item.value)
    
    if (!rarityStats[item.rarity].scarcities[item.scarcityLevel]) {
      rarityStats[item.rarity].scarcities[item.scarcityLevel] = 0
    }
    rarityStats[item.rarity].scarcities[item.scarcityLevel]++
  })
  
  // Para cada pack, calcular valor esperado
  console.log('üí° VALOR ESPERADO POR TIPO DE PACK:\n')
  
  for (const pack of packs) {
    console.log(`üì¶ ${pack.name} (${pack.price} cr√©ditos):`)
    
    let expectedValue = 0
    let analysis = []
    
    pack.probabilities.forEach(prob => {
      const rarityData = rarityStats[prob.rarity]
      if (rarityData) {
        const avgValue = rarityData.values.reduce((a, b) => a + b, 0) / rarityData.values.length
        const contribution = (prob.percentage / 100) * avgValue
        expectedValue += contribution
        
        analysis.push({
          rarity: prob.rarity,
          probability: prob.percentage,
          avgValue: Math.round(avgValue),
          contribution: Math.round(contribution),
          minValue: Math.min(...rarityData.values),
          maxValue: Math.max(...rarityData.values)
        })
      }
    })
    
    console.log(`   üí∞ Valor esperado: ${Math.round(expectedValue)} cr√©ditos`)
    console.log(`   üìä ROI: ${((expectedValue / pack.price) * 100).toFixed(1)}%`)
    console.log('')
    
    analysis.forEach(item => {
      console.log(`      ${getRarityEmoji(item.rarity)} ${item.rarity}: ${item.probability}%`)
      console.log(`         Valor m√©dio: ${item.avgValue} cr√©ditos (${item.minValue}-${item.maxValue})`)
      console.log(`         Contribui√ß√£o: ${item.contribution} cr√©ditos`)
      console.log('')
    })
    
    // An√°lise de lucratividade
    const profitability = expectedValue - pack.price
    const profitabilityPercent = ((profitability / pack.price) * 100).toFixed(1)
    
    if (profitability > 0) {
      console.log(`   ‚úÖ Pack lucrativo: +${profitability} cr√©ditos (${profitabilityPercent}%)`)
    } else {
      console.log(`   ‚ö†Ô∏è  Pack com perda: ${profitability} cr√©ditos (${profitabilityPercent}%)`)
    }
    console.log('')
  }
  
  // 3. An√°lise de acessibilidade vs pacotes de cr√©ditos
  console.log('üéØ ACESSIBILIDADE: Pacotes de Cr√©ditos vs Pre√ßos dos Itens\n')
  
  // Para cada pacote de cr√©ditos, ver que itens pode comprar
  creditPackages.forEach(pkg => {
    console.log(`üí≥ R$ ${pkg.price.toFixed(2)} (${pkg.credits} cr√©ditos):`)
    
    // Quantos packs cada tipo pode comprar
    packs.forEach(pack => {
      const packsAffordable = Math.floor(pkg.credits / pack.price)
      if (packsAffordable > 0) {
        console.log(`   üì¶ ${pack.name}: ${packsAffordable} packs (${packsAffordable * pack.price} cr√©ditos)`)
      }
    })
    
    // Que raridades pode conseguir diretamente
    const affordableItems = {}
    items.forEach(item => {
      if (item.value <= pkg.credits) {
        if (!affordableItems[item.rarity]) {
          affordableItems[item.rarity] = 0
        }
        affordableItems[item.rarity]++
      }
    })
    
    console.log('   üéÅ Itens acess√≠veis diretamente no marketplace:')
    Object.entries(affordableItems).forEach(([rarity, count]) => {
      const total = rarityStats[rarity].count
      const percentage = ((count / total) * 100).toFixed(1)
      console.log(`      ${getRarityEmoji(rarity)} ${rarity}: ${count}/${total} (${percentage}%)`)
    })
    console.log('')
  })
  
  // 4. Recomenda√ß√µes de balanceamento
  console.log('üîß AN√ÅLISE DE PROBLEMAS E RECOMENDA√á√ïES:\n')
  
  const problems = []
  const recommendations = []
  
  // Verificar se algum pack √© muito lucrativo
  for (const pack of packs) {
    let expectedValue = 0
    pack.probabilities.forEach(prob => {
      const rarityData = rarityStats[prob.rarity]
      if (rarityData) {
        const avgValue = rarityData.values.reduce((a, b) => a + b, 0) / rarityData.values.length
        expectedValue += (prob.percentage / 100) * avgValue
      }
    })
    
    const roi = ((expectedValue / pack.price) * 100)
    
    if (roi > 120) {
      problems.push(`${pack.name}: ROI muito alto (${roi.toFixed(1)}%) - pack muito lucrativo`)
      recommendations.push(`Reduzir probabilidades de itens raros no ${pack.name} ou aumentar pre√ßo`)
    } else if (roi < 80) {
      problems.push(`${pack.name}: ROI muito baixo (${roi.toFixed(1)}%) - pack pouco atrativo`)
      recommendations.push(`Aumentar probabilidades de itens raros no ${pack.name} ou reduzir pre√ßo`)
    }
  }
  
  // Verificar gaps entre pacotes de cr√©ditos
  for (let i = 0; i < creditPackages.length - 1; i++) {
    const current = creditPackages[i]
    const next = creditPackages[i + 1]
    
    const currentEfficiency = current.credits / current.price
    const nextEfficiency = next.credits / next.price
    
    const efficiencyGain = ((nextEfficiency / currentEfficiency - 1) * 100)
    
    if (efficiencyGain > 50) {
      problems.push(`Gap muito grande entre R$ ${current.price} e R$ ${next.price} (${efficiencyGain.toFixed(1)}% mais eficiente)`)
      recommendations.push(`Adicionar pacote intermedi√°rio entre R$ ${current.price} e R$ ${next.price}`)
    }
  }
  
  // Verificar itens inacess√≠veis
  const maxCreditsPackage = Math.max(...creditPackages.map(p => p.credits))
  const inaccessibleItems = items.filter(item => item.value > maxCreditsPackage)
  
  if (inaccessibleItems.length > 0) {
    problems.push(`${inaccessibleItems.length} itens custam mais que o maior pacote de cr√©ditos`)
    recommendations.push('Considerar pacote de cr√©ditos maior ou reduzir valores dos itens mais caros')
  }
  
  if (problems.length > 0) {
    console.log('‚ö†Ô∏è  PROBLEMAS IDENTIFICADOS:')
    problems.forEach((problem, i) => {
      console.log(`   ${i + 1}. ${problem}`)
    })
    console.log('')
  } else {
    console.log('‚úÖ Nenhum problema cr√≠tico detectado!')
    console.log('')
  }
  
  if (recommendations.length > 0) {
    console.log('üí° RECOMENDA√á√ïES:')
    recommendations.forEach((rec, i) => {
      console.log(`   ${i + 1}. ${rec}`)
    })
    console.log('')
  }
  
  // 5. Estat√≠sticas finais
  console.log('üìà ESTAT√çSTICAS FINAIS:')
  console.log('')
  
  // ROI m√©dio dos packs
  let totalROI = 0
  let packCount = 0
  
  for (const pack of packs) {
    let expectedValue = 0
    pack.probabilities.forEach(prob => {
      const rarityData = rarityStats[prob.rarity]
      if (rarityData) {
        const avgValue = rarityData.values.reduce((a, b) => a + b, 0) / rarityData.values.length
        expectedValue += (prob.percentage / 100) * avgValue
      }
    })
    
    const roi = (expectedValue / pack.price) * 100
    totalROI += roi
    packCount++
  }
  
  const avgROI = totalROI / packCount
  console.log(`   üé≤ ROI m√©dio dos packs: ${avgROI.toFixed(1)}%`)
  
  // Efici√™ncia dos pacotes de cr√©ditos
  const efficiencies = creditPackages.map(pkg => pkg.credits / pkg.price)
  const avgEfficiency = efficiencies.reduce((a, b) => a + b, 0) / efficiencies.length
  const maxEfficiency = Math.max(...efficiencies)
  const minEfficiency = Math.min(...efficiencies)
  
  console.log(`   üí∞ Efici√™ncia cr√©ditos/real: ${minEfficiency.toFixed(1)} - ${maxEfficiency.toFixed(1)} (m√©dia: ${avgEfficiency.toFixed(1)})`)
  
  // Distribui√ß√£o de valores por raridade
  console.log(`   üéØ Distribui√ß√£o de valores:`)
  Object.entries(rarityStats).forEach(([rarity, data]) => {
    const min = Math.min(...data.values)
    const max = Math.max(...data.values)
    const avg = Math.round(data.values.reduce((a, b) => a + b, 0) / data.values.length)
    console.log(`      ${getRarityEmoji(rarity)} ${rarity}: ${min}-${max} cr√©ditos (m√©dia: ${avg})`)
  })
  
  await prisma.$disconnect()
}

function getRarityEmoji(rarity) {
  const emojis = {
    'COMUM': 'üü´',
    'INCOMUM': 'üü¢',
    'RARO': 'üîµ',
    'EPICO': 'üü£',
    'LENDARIO': 'üü°'
  }
  return emojis[rarity] || '‚ö™'
}

comprehensiveBalanceAnalysis().catch(console.error)